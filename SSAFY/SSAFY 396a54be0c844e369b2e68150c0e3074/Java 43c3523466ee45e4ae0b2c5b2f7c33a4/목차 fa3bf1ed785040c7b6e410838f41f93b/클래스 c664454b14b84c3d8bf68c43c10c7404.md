# 클래스

## 생성자

- 인스턴스를  초기화 하는 메소드
- 다른 생성자를 만들면 기본 생성자는 자동으로 만들어지지 않는다
- 생성자 안에서 this 로 다른 생성자를 호출할 때는 가장 첫 줄에 있어야 한다.
    - 그냥 자바가 그렇게 만들어진 것임

```java
public class Person {
	
	public String name;
	public int age;
	public String hobby;
	
	Person() {
			this("무명", 0, "취미없음"); // 밑에 오버로딩 한 생성자 사용
	}
	
	Person(String name, int age, String hobby){
		this.name = name;
		this.age = age;
		this.hobby = hobby;
				
	}
	
}
```

## 인스턴스

- 인스턴스가 많을 때
    - 배열에 객체를 저장
    - 배열의 인덱스를 이용해서 객체의 메소드를 호출
        - 모두 출력하려면 반복문을 이용
    
    ```java
    Restaurant[] arr = new Restaurant[2];
    		arr[0] = new Restaurant(101,"을밀대","서울","냉면",4);
    		arr[1] = new Restaurant(401,"도마29","대구","연어초밥",3);
    
    for(Restaurant res : arr) {
    			System.out.println(res.toString());
    ```
    

## 객체 배열 관리

### 싱글턴 패턴

객체를 유일하게 하나만 만들게 하는 것

내 클래스 안에서 생성자를 private static으로 생성한다. 

나중에 객체를 만들고 싶으면 getter을 이용해서 이미 생성한 객체를 반환한다. 

- 객체가 하나만 만들어져도 되는 경우
    - 테트리스 맵은 하나만 만들어지면 된다.
    
    ```java
    public class Manager{
    
    	private static Manager instance = new Manager();
    // 메모리 로딩시점에 나 자신을 생성해서 갖고 있겠다.
    
    	private Manager() {}
    	//생성자를 외부에서 건들지 못하게 막는다.
    
    	public static Manager getInstance(){
    	  return instance;
    	//static으로 만들어서 객체 생성 없이 만들 수 있게 한다.    ㅡ 
    	}
    }
    //객체를 만들고 싶을 때마다 같은 인스턴스를 참조하게 한다. 
    //클래스 내부 멤버면수나 속성을 바꿀일이 없으니까
    ```
    
    ```java
    public class ManagerTest {
    	public static String main (String[] args) {
    
    		Manager manager_1 = Manager.getInstance();
    		// 객체 생성 완료!
    		// 
    	}
    }
    ```
    
    - 내부의 count, score등도 하나만 만들어지면 된다.
    - 학사관리 시스템의 학생들 정보를 담은 배열도 하나
- 나머지는 다른 것과 다 같음
    - 인스턴스의 멤버변수에 넣는 값들도 메서드로 똑같이 갱신할 수 있음
    - 인스턴스를 만드는 과정만 다른 것!

## 추상클래스

- 설계도인데 객체를 생성하지 않는다.
    - 와꾸만
- 부모클래스의 타입으로 자식클래스의 인스턴스를  참조하려면 아무튼 메서드가 선언되어있어야 한다.
    - 안 그러면 부모가 가지지 않는 메소드를 쓰지 못해서 코드 구현이 복잡해짐
    - 동적바인딩 불가
    
    **→ 여기서 추상클래스가 나왔다.** 
    

```java
public abstract class Class_1 {	// 추상메소드를 하나라도 포함하면 추상클래스
	public abstract void function(); }
// {} 본문은 없어도 된다. 어차피 오버라이딩 되니까.
```

- 설계도에 추상 메소드가 하나라도 있으면 추상클래스
    - 추상 메소드가 있으면 해당 클래스의 객체를 생성할 수가 없다.
    - 상속을 해서 오버라이딩 해야 객체 생성 가능
        - 자식클래스에서 반드시 오버라이드해야 한다.
    - 자식클래스가 오버라이딩 하지 않으면 본인도 추상클래스가 된다.
        - 그러면 객체 생성불가.
        - 아무튼 객체 생성하려면 오버라이딩!!
- 다형성 활용 가능!
    - 이 추상클래스를 상속받은 자식 클래스는 이 기능이 반드시 있다. 를 보장

## 인터페이스

- 인터페이스는 static 영역에 올라가있는 설계도
- 서로다른 시스템이 상호작용 하기 위한 접점의 규격
- 클래스와 유사하게 작성 가능. class 대신 interface키워드 사용
- 모든 메서드가 추상메서드 : 이 추상메서드를 구현하겠다는 약속

```java
public interface Interface_1 {
	public abstract void method_1(); 
	//접근 제한자랑 abstract를 쓰지 않아도 기본적으로 추상메소드 이기 때문에 생략가능
	// -> **void method_1**
	public static final type 상수_1 = 10;
	//모든 변수는 public static final이다. 기본적으로 상수이기 때문에 생략가능
	// -> **type 상수_1** 
}
```

- 멤버변수는 인터페이스를 구현하는 **클래스** 안에 선언해줘서 그 클래스의 객체들이 가지게 하는 것.
    - 인터페이스는 데이터를 저장하는 멤버변수를 가지고 있을 필요가 없음.

<구현>

```java
public class Class_1 implements Interface_1 {
	
}
```

- 해당 객체가 인터페이스를 구현했다면 **인터페이스 타입으로 객체 참조 가능**
- 클래스는 단일 상속이지만, 인터페이스는 다중 구현 가능
- 인터페이스는 인터페이스를 상속받을 수 있다.
    - 다중구현 가능

```java
interface Movable {
}

interface Cookable {

}

public class Chef implements Movable, Cookable {

} // 다중 구현 가능
```

### default method

- 인터페이스에 구현부가 있는 메서드를 작성할 수 있다.
- public 접근 제한자를 사용해야하며 생략 가능
- **갑자기 인터페이스에 기능(메서드)를 추가하고 싶을 때 모든 상속자들이 오버라이딩 할 수가 없으니 사용**
    - 구현(오버라이딩) 안 해도 들어있다

```java
public default void info(){}
```

### static method

- 클래스의 static 메서드와 사용방법이 동일
- **인터페이스 이름**으로 메서드에 접근하여 사용

→ default method와 static method가 들어있는 인터페이스를 다중 구현했을시 메서드가 충돌을 하면 오버라이드 해주어야 한다. 

## 제네릭

- 다양한 종류의 객체들을 다루는 메서드나 컬렉션 클래스에서 컴파일 시 타입을 체크해 주는 기능
- 객체의 타입 안전성을 제공한다.
- 형변환의 번거로움이 없어지므로 코드가 간결해진다.
- 클래스 안에서 사용되는 자료형을 구체적으로 명시하지 않고 T와 같이 타입 매개변수를 이용하는 클래스
    - 클래스 오버로딩 느낌?!

<선언>

```java
public class ClassName<T>{}
public interface InterfaceName<T>{}
```

<Object type으로 구현하면>

```java
class Box {
	private Object obj;

	public Object getObj() {
		return obj;
	}

	public void setObj(Object obj) { //Object이기 때문에 어떤 type도 들어갈 수 있따.
		this.obj = obj;	
	}
}
```

- 이렇게 구현하면 항상 Object형으로 반환하므로 사용할 때형변환을 해줘야 한다.

→ 따라서 제네릭 클래스 생성

**<제네릭 클래스>**

```java
class Box<T> {
	private T t;
	
	public T getT() {
		return t;
	}
	public void SetT(T t) {
		this.t=t;	
	}
}

public class BoxText {
	public static void main(String[] args) {
		Box<Integer> intBox = new Box<Integer>(); // 추청이 가능한 경우 new 에서 타입생략가능+
		intBox.setT(123); //이제 Integer타입만 들어갈 수 있다.
	}
}
```

**<제한된 제네릭 클래스>**

```java
Class Box<T extends Person> { 

/* 구현은 위와 같음
*/
}
```

- 타입으로는 Person이나 Person을 상속한 클래스 타입만 들어온다는 것을 알 수 있음.
- 인터페이스도 제한하고 싶으면 &으로 연결

```java
Class Box<T extends Bird & AbleToFly & AbleToSwim>
// Bird의 자손이면서 AbleToFly와 AbleToSwim을 구현한 타입만 올 수 있다. 
```

**<와일드카드>**

```java
Generic type <?>
Generic type <? extends T>
Generic type <? super T>
```