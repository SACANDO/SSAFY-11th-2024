# Spring

jstl 링크 : [https://jakarta.ee/specifications/tags/2.0/jakarta-tags-spec-2.0](https://jakarta.ee/specifications/tags/2.0/jakarta-tags-spec-2.0)

# 수정순서

1. MYSQLschema 확인
    1. DTO 변수
2. DAO확인
3. MAPPER확인
    1. 변수명은 schema대로
4. SERVICE확인
5. SERVICEIMPL확인
6. CONTROLLER확인

### 관계

- DB
    - DAO - mapper의 id명과 method명이 일치해야 함
        - Mapper - DB의 속성명과 같아야 함
    - DTO
        - 자료형이 DB와 같아야 함
        - 이름이 camelCase로 매칭되어야 함

![Untitled](Spring%2084949ce43975423dad7ddeac91c1877c/Untitled.png)

### Intro

Client(요청을 보내는 쪽) 와 Server(응답을 보내는 쪽)사이의 request와 response

Client와 Server사이 → 서버개발자

http(s) : hyper text transfer protocol. 규약

Server는 data를 보낸다. 

js는 data를 받아서 화면을 재구성. → 프론트엔드 개발자

server에서 data를 주는 것 까지 → 백엔드 개발자

브라우저도 하나의 컴퓨터/ sts실행도 하나의 컴퓨터를 킨 것 / DB도 컴퓨터 한대

서버에 배포 : AWS 임대해서 프로그램 올려놓고 f11눌러논 것

브라우저를 이용해서 주소를 입력 (edu.ssafy.com)→ 요청 : 에듀사피가 올라가 있는 서버컴퓨터에 요청을 보내는 것. 

webserver는 정적 페이지를 보내준다. 모든 사람이 똑같은 화면을 얻는다. 

동적페이지를 요청 받으면 webserver은 Application Server에 요청을 보낸다. 

Application Server 

- Presentation
- Business Logic
- Persistence Logic

Web Application Server(WAS) :  톰캣

URL : 통합 자원 위치. 도로명 같은 것

dto : data transfer object

404 : 서블릿 맵핑 안되어있을 때나는 에러

---

## Servlet

- 웹 어플리케이션의 서버측 프로그램
- java를 이용하여 웹 페이지 동적 생성
- Httpservlet 상속

# JSP(Java Servlet Page)

- 실행 시 servlet으로 변환된 후 실행
    - 컴파일러가 servlet.java로 바꾼다.
- HTML내에 Java를 작성하여 동적으로 웹페이지를 생성하여 브라우저에게 돌려주는 페이지

## 데이터 전송방식

- main에서 client의 요청이 들어온다.
    - 요청에 따른 메소드 실행 → jsp파일에 요청을 forward로 전송해서 데이터를 보낸다.
    - 
    - 일단 서블릿으로 다 갖고 와
- 

### 포워드

- client가 요청한 페이지 jsp가 생성한 서블릿이 생성한 html을 응답으로 넘겨준다.
- post요청→ 톰캣이 req, resp 객체를 생성 → main서블릿으로 넘겨줌 → doPost 실행 → result를 response해줘야 하는데, 그 것은 result가 만들어야 하기 때문에 result.jsp가 만든 서블릿에 요청 → main이 받았던 req와 resp를 그대로 받은 것임. form데이터의 파라미터들이 그대로 req에 들어있다. → HTML응답을 resp에 담아서 보냄
    - servlet을 수정 (자바코드 수정) → 서버를 재시작 해줘야 함
    - jsp파일 수정 → 응답이 왔을 때 톰캣이 서블릿으로 바꿈 → 서버 재시작 필요없음
    - 주소는 main 그대로
        - result는 그냥 main이 시키는 거 하고 main한테 html넘겨준 거임
- request에 데이터를 받아서 전달하여 처리해야 할 때,
- 결과값을 가공하여 전송해야 할 때 (화면에 출력해야할 때 등)

### 리다이렉팅

- 주소가 바뀐다. 그 주소로 가라고 했기때문
- 최초의 req, resp가 유지되지 않는다. 톰캣이 req, resp를 다시 생성한다.
    - 따라서 req에 form의 data가 없어서 에러가 난다.
- 그냥 페이지만 옮길 때 (로그인 후 메인화면으로 돌아가기 등)

# HTTP

인터넷에서 데이터 통신을 위한 표준화된 규약이나 규칙

- TCP(Transmission Control Protocol) : 서로 연결을 확인하고 데이터 송수신.
- UDP(User Datagram Protocol) : 연결 확인 하지 않고 냅다 보낸다. 보증 없다.
    - 받는 컴퓨터가 꺼져있으면 못받을 수도
    - 단, 빠르다.
- 클라이언트 : 내 브라우저(크롬)
- 서버 : was(톰캣)

- 서버는 전송 후 연결을 끊는다.
- 서버는 클라이언트의 상태를 저장하지 않는다.
    - 클라이언트의 상태를 알 수 없기 때문에 클라이언트가 서버에 추가적인 데이터 전송을 해야 함
- 단 브라우저 쿠키, 서버세션등을 이용하여 상태유지
    - 클라이언트가 스스로 상태 저장

### Cookie

- 쿠키 : 브라우저 별로 관리
    - 다른 브라우저를 켜면 그 브라우저는 다른 브라우저의 쿠키가 없다.
    - 웹 서버가 클라이언트의 웹 브라우저에 저장하는 작은 데이터 조각
    - 필요에 따라 요청시 서버로 같이 전송
    - key : Value 형태의 문자열 데이터
    - 와스가 쿠키 반죽 후 우리한테 보내고 연결을 끊는다.
    - client는 쿠키를 저장, 해당 서버를 요청할 때 요청과함께 쿠키를 전송한다.

### Session

- was 안에 session영역이 있음
- 클라이언트(브라우저)가 세션에 접근 할 수 있도록 sessionid를 이용해 구분
- 클라이언트는 나와 관련있는 서버의 sessionid를 알고 있어야한다.
- 요청을 받으면 서버는 Jsessionid라는 쿠키를 자꾸 만들어서 클라이언트에 보낸다. client는 서버에 있는 session영역에 접근할 수 있다.
- 메모리가 허용하는 용량까지 제한없이 저장가능
- 클라이언트가 페이지를 요청 → 서버는 쿠키에 session id가 있는지 확인 → session id가 존재하지 않으면 sessionid를 생성해 쿠키에 쓴 다음 반환한다.

### JSP 태그

1. <% %> :  스크립트릿. servlet변경후 service()로 작동 됨. 
    1. **그러면 <%  %>와 <%! 함수%>는 같은 건가?** 
        - **NO**
        - <%  %>는 servlet의 service영역에 저장된다.
2. <%! %> : 선언부. 클래스 영역에 작성 됨.(클래스영역이 생긴다는 말이 아니라 그냥 고런 너낌)
그래서 함수와 필드를 작성할 수 있음. 스태틱. 
3. <%= %> : 표현식. out.print(); 출력, 함수, 계산식.  
4. <%- - %> : 서블릿 변환 안된다. 
5. <%@ %> : 지시자 
    1. page : jsp 설정. lang, encoding, error, import 등
    2. include : 다른 jsp 끼워 넣으려고 할 때. header, footer 등
    3. taglib

## EL(Expression Language) - 출력용

- JSP내에 데이터를 다루는 데 사용되는 스크립팅 언어
- JSP 스크립트의 **표현식 (<%= %>)**를 대신하여 속성값을 쉽게  **출력**할 수 있도록 고안된 언어
    - ${expr}
    - 변수, 속성, 메서드 호출 등을 포함할 수 있음
- **객체가 null이면 아무것도 안 뜬다.**

### JavaBeans

Java로 작성된 재사용 가능한 소프트웨어 컴포넌트

- 클래스는 직렬화 되어야 한다.
- 클래스는 기본 생성자를 가지고 있어야 한다.
- 클래스의 속성들은 게터와 세터를 사용해 접근할 수 있어야 한다.
- 클래스는 필요한 이벤트 처리 메서드 들을 포함하고 있어야 한다.
    
    EL 표현식을 이용하여 접근이 가능하다
    
- . (dot) 혹은 [”속성명”]을 사용할 수 있다.
- 인스턴스만을 작성하면 toString() 메서드가 동작한다.

## JSTL(JSP Standard Tag Library)

- JavaEE기반의 웹 어플리케이션 개발을 위한 컴포넌트 모음
- JSP스크립트와 html 코드가 섞여서 복잡한 구조를 가짐
    
    이를 간결하게 작성하기 위해서 자바코드를 태그 형태로 작성해 놓은 것
    
- 유용한 커스텀 태그들을 모아서 표준화 한 것
- jar파일 or Maven

### JSTL기능

- 간단한 프로그램 로직 구현 기능 - 변수 선언, if 문장, for문 등

```java
<%@ taglib prefix="c" uri = "jakarta.tags.core" %>

<c:out value="Hello! JSTL"/>
```

# Spring DI

프레임 워크 : SW특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합

### spring프레임워크를 사용하기 위한 설정

1. maven → springcontext dependency추가
2. resources 소스폴더 생성(src와 동일) → appliactionContext.xml생성
3. springFramework reference → xml schemas → the context schema복붙
4. bean 등록 하기 위해서는 위 beans블록 안에 bean을 등록하면 됨 (xml방식 & annotation방식)

### springContainer build

1. ApplicationContext를 생성

```java
ApplicationContext context = new GenericXmlApplicationCopntext("applicationcontext.xml");
```

### 2. bean 가져오기

context에  등록한 bean을 가져온다.

```java
context.getBean("클래스명");
또는
context.getBean("클래스명",클래스명.class);
```

어디서도 new 로 인스턴스를 만들지 않았는데 알아서 스프링이 가져왔다.

bean으로 등록하면 컨테이너를 빌드할 때 스프링이 모든 빈들을 생성해버리고, 필요할 때마다 가져온다.  기본적으로 객체들을 싱글턴으로 관리한다. 

### 1. bean등록하기

세가지 방법으로 applicationContext에 bean 등록

1. xml

xml에 직접 등록

```java
<bean class = ""></bean>
```

1. annotation
- xml에 component scan으로 등록

```java
<context:component-scan base-package="" />
```

- bean으로 등록하고 싶은 클래스 위에 어노테이션 붙이기

```java
@Component
```

- 의존성 주입 : 생성자 주입, 설정자 주입 - 매칭이되는 bean과 자동 매칭

```java
@Autowired
```

같은타입이 여러개일 경우 빈을 지정

```java
@Qualifier("빈이름")
```

1. java config

```java
ApplicationConfig.java 생성 // config파일 하나 만들어놓는 것
```

```java
@Configuration
public class ApplicationConfig
	@Bean
	public Classname classname() {}
```

또는

```java
@Configuration
@ComponentScan(basePackages = {"패키지명"})

등록하고 싶은 bean에
@Component
```

## DispatcherServlet설정

### 1. Servlet WebApplicationContext

웹과 관련

- Controlers
- viewResolver
- HandlerMapping

### 2. Root WebApplicationContext

모델, DB와 관련

- Services
- Repositories

### Spring Web MVC시작

1. Spring web mvc를 pom.xml에 등록
2. web.xml에 DistpatcherServlet 등록
    - 경로는 아무 클래스에 dispatcherServlet 쳐서 임포트된 경로 가져오기
3. WEB-INF안에 root-context와 servlet-context 생성

### 의존관계역전

### Spring container Build

- Container?
    - 스프링에서 핵심적인 역할을 하는 객체를 Bean이라고 함
    - Container는 Bean의 인스턴스화 조립, 관리역할, 사용 소멸에 대한 처리 담당
    - 객체들을 싱글턴으로 관리
- Context?
    - 메모리 공간(Container)
        - Bean들의 집합이 있음.
        - Bean들을 관리
    - 처음에 서버가 시작될 때 스프링이 Bean을 생성하여 메모리에 올린다.

### XML

- XML :빈생성+의존성생성
    - 빈 설정 : @bean
        - 생성자, setter 주입
- **XML+Anotation**
    - xml : 빈 설정 - context:component-scan base-package>
        - 필드주입도 가능
    - xml : 나는 annotation 쓰겠다.

### Java

- Java : 빈생성 + 의존성 생성
    - 빈생성 @bean : 메서드 이름 = 빈의 이름, 반환형 = 빈의 타입
- **Java+Annotation**
    - java 의 빈 사용 : Configuration + ComponentScan(basePackages = {})
    - @component를 찾아서 bean으로 생성
    - 

Annotation 공통

- component : 빈으로 등록
- Autowired : 스프링에의해 자동으로 주입되는 어노테이션
- Qualifier :
    
    

# AOP 관점지향 프로그래밍

<aside>
💡 OOP is A PIE(추상화 다형성 상속 캡슐화)

</aside>

AOP는 OOP를 대체하는 것이 아니라 보조하는 목적

부가 기능 : Cross-Cutting Concerns

- Target : 부가 기능을 붙일 핵심 기능
- **Aspect : AOP의 기본 모듈. 공통관심사항(부가기능들)**
- Join Point : 부가기능이 실행될 수도 있는 곳들 ex) 인출, 송금 등
- Point Cut : Join Point 중에서 Advice를 적용하기 위한 조건
- Advice : 부가기능, 특정 Join Point에서 취해지는 행동
- Weaving : Point Cut으로 결정한 Target의 Joint Point 에 Advice를 적용하는 것.
Spring AOP는 런타임에 수행 (실행되는 중에)
- AOP Proxy : AOP를 구현하기 위해 AOP Framework에 의해 생성된 객체
    - interface를 구현한 proxy구현체를 만든다
    - 따라서 bean으로부터 객체를 생성할 때 interface 타입으로 받아야 함

## Proxy

- 대리인
- 프록시 서버 : 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용프로그램
    - 외부에서 접근할 수 없는 서버 등에 접근할 때
    - 보안모듈이 깔려있는 서버 등
    - 국적변환 서버 등
    - VPN
- 접근 제어와 부가기능 추가 수행 가능

# MVC

![Untitled](Spring%2084949ce43975423dad7ddeac91c1877c/Untitled%201.png)

### Advice Type

- before : target메서드 호출 이전
- after : target이후 finally처럼 동작
- after returning : target 정상 동작 후
- after throwing : target 에러 발생 후
- around : target메서드 실행시기, 방법, 실행 여부 결정

# Listener & Filter

### Listener

- 이벤트가 발생하기를 기다리다가 실행되는 객체
- 이벤트 : 버튼클릭, 컨테이너 빌드완료, 웹앱 시작, GTTP요청수신 등
- 서블릿 컨테이너에서 발생하는 이벤트 감지
- web.xml파일에 <listener> 태그 이용
- 보통 선언된 순서대로 실행되지만 리스너는 독립적으로 동작할 수 있도록 설계하는 것이 좋음.

### Filter

- 요청과 응답 데이터를 필터링하여 제어, 변경하는 역할
- 사용자의 요청이 servlet에 전달되어지기 전에 필터를 거침
- servlet으로부터 응답이 사용자에게 전달되어지기 전에 필터를 거침
- 필터체인을 통해 연쇄적 동작 가능

# Interceptor

![Untitled](Spring%2084949ce43975423dad7ddeac91c1877c/Untitled%202.png)

- 필터와 비슷한데 필터보다 기능이 많다.
- HandlerInterceptor을 구현한 것
- **접근제어, 로그 등 비즈니스 로직과 구분되는 반복적이고 부수적인 로직처리**
    - 사용자가 접근하면 안되거나 제한할 때 interceptor 후 응답
    - **preHandle()**
        - Controller(핸들러) 실행 이전에 호출
        - true를 반환하면 계속 진행
        - false를 반환하면 요청 종료
    - postHandle()
        - Controller 실행 후 호출
        - 정상실행 후 추가 기능 구현 시 사용
        - Controller에서 예외 발생시 해당 메서드는 실행되지 않음
    - afterCompletion()
        - 뷰가 클라이언트에게 응답을 전송한 뒤 무족권 실행
        - 컨트롤러에서 예외 발생시 네번째 파라미터로 전달이 된다. 기본은 null
        - contreoller에서 발생한 예외 혹은 실행시간 같은 것들을 기록하는 등 후처리 시 주로 사용

# File Upload&Download