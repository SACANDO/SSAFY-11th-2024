# 컬렉션

## 컬렉션 프레임워크

- 정적 자료구조(static data structure)
    - 고정된 크기의 자료구조
    - 배열이 대표적인 정적 자료구조
    - 선언 시 크기를 명시하면 바꿀 수 없음
- 동적 자료구조
    - 요소의 개수에 따라 자료구조의 크기가 동적으로 증가하거나 감소
    - 리스트, 스택, 큐 등
- 자료구조는 어떤 구조에서 얼마나 빨리 원하는 데이터를 찾는 가에 따라 결정
    - 순서를 유지할 것인가?
    - 중복을 허용할 것인가?
    - 다른 자료구조들에 비해 어떤 장단점을 가지는가?
- **인터페이스로 접근**. 인터페이스 밑에 구현되어있는 클래스들이 있음
- collection
    - List : 크기 변경이 가능한 배열. 순서O = 인덱스로 접근. 데이터 중복 가능.
        - ArrayList : 1.5배씩 늘어남 (50%) / 내부적으로 배열로 구현되어있기 때문에 배열의 성질을 모두 가지고 있음.
        - LinkedList :
        - Vector : 2배씩 늘어남. (100%)
        - Stack
    - Set : 효율적인 중복 데이터 제거 수단. 순서 유지x. 데이터 중복 불가.
        - HashSet : hashcode로 중복제거. Hashtable로 관리하는데 성능면에서 우수함
        - TreeSet : red-black tree로 관리
    - queue : FIFO.
        - LinkedList
    - map : key와 value의 쌍으로 데이터를 관리하는 집합. key의 중복 불가. value는 중복 가능
        - Hashmap
        - hashtable
        - treemap
        - properties
        

### Collection interface

```java
boolean add(E e)
void add(int index, E e)
boolean addAll(Collection<? extends E> c)

contains(Object o)
containsAll(Collection<?> c)
boolean equals()
isEmpty()
iterator()
size()

boolean remove(E e) //**인덱스, vlaue 둘다 가능**, 제일 앞에서 찾은거 하나만 지워진다. 
//모두 지우려면 for문으로 뒤에서 부터 탐색 : 삭제가 되면 동적으로 배열 크기가 줄기 때문에
E remove(int index)

void clear()
removeAll(Collection<?> c) 
boolean retainAll(Collection<?> c)

toArray()
```

### List

데이터 조회 : arraylist가 가장 빠름

중간에 추가 : linkedlist가 가장 빠름

**<리스트를 배열로 변환하기>**

```java
public User[] getList() {

		User[] res = new User[userList.size()];

		return this.userList.toArray(res); //그냥 toArray()를 쓰면 type이 object가 됨 
	}
```

### Set

중복을 판단하는 방법

1. hashCode() 오버라이드 → 특정 value의 hashcode를 반환.
2. equals() 오버라이드.

### Map

```java
Map<String, String> map = new HashMap<>();
map.put("서울6반", "옥진석");

System.out.println(map.get("서울6반"));
map.put("서울6반", "송예진"); // key값이 같으면 value가 대체 된다. 

map.containsKey("서울6반"); //키로 찾기 - boolean
map.containsValue("송예진"); // vlaue로 찾기 - boolean

for(String key : map.keySet()) {
        	System.out.printf("%s : %s \n", key, map.get(key));
        	
        }
        
for(Map.Entry<String, String> entry : map.entrySet()) {
        	System.out.println(entry.getKey() + " : " + entry.getValue());
        }
```

**마찬가지로 중복을 없애기 위해서는**

```java
@Override
	public int hashCode() {
		// TODO Auto-generated method stub
		return id.hashCode();
	}

	@Override
	public boolean equals(Object obj) {
		// TODO Auto-generated method stub
		if(obj instanceof Person) {
			Person other = (Person) obj;
			return id.equals(other.id);
		}
		return false;
	}
    
}
```

### Queue

```java
boolean offer(E e) // 데이터 추가, add도 가능
E peek() // 가장 앞 값 확인
E poll() // 가장 앞 데이터 빼기
boolean isEmpty() // 큐가 비었는지
```

```java
Queue<Integer> queue = new LinkedList<>();

for(int i =0; i<5; i++) {
    		queue.offer(i);
    	}

while(!queue.isEmpty()) {
    		System.out.println(queue.poll());
    	} // 가장 먼저 들어온 데이터 부터 뺌
```

### Stack

- 가장 위에있는 값 : Top
- 스택은 인터페이스가 없고 클래스임

```java
E push(E e) // Top위에 추가
E peek()
E pop()
boolean imEmpty()
```

```java
Stack<Integer> stack = new Stack<>();

for(int i=0; i<5; i++) {
    		stack.push(i);
    	}

while(!stack.isEmpty()) {
    		System.out.println(stack.pop()); 
    	}
```

## 정렬(sort)

- 순서가 있는 Collection만 정렬 가능

    **컬렉션에 있는 static sort메소드 사용**

```java
Collections.sort(Object obj); // obj가 comparable interface를 구현하고 있을 때
```

> Collections인터페이스의 sort를 사용하려면 sort 메소드가 부르는 compareTo에 대해 정의가 되어있어야 하는데, Integer나 String과 같이 이미 정의 되어있는 것 말고, 내가 생성한 클래스에는 정의되어 있지 않다. 따라서 내 클래스에 compareTo를 오버라이딩 해야 하고, compareTo는 comparable인터페이스의 추상메소드이기 때문에 implements후 오버라이딩 하여 구현한다.
> 

### Comparable interface

1. 해당 클래스에 comparable interface를 구현
    1. **implements** Comparable<class name>
    2. compareTo 오버라이딩
2. Comparator 만들기

> 만약 compareTo 오버라이딩을 하지 않고, sort에 comparator을 매개변수로 같이 넣어주게되면 내부적으로 다른 sort방식을 쓴다. 주로 람다표현식을 쓰기 위해 씀
> 

### Comparator

comparable interface를 구현하지 않아도 Comparator가 있으면 정렬 할 수 있다.

1. compare 추상메소드가 있는 Comparator인터페이스 implements
2. Person을 정렬할 수 있도록 하는 compare 오버라이딩

```java
public class PersonComparator implements Comparator<Person>

@Override
    public int compare(Person o1, Person o2) {
        // 1. 이름순
        // 2. 나이순
        if (o1.name.equals(o2.name))
            return o1.age - o2.age; 
        
        return o1.name.compareTo(o2.name);
    }
```

comparator을 만들어 줬을 때 사용하는 방법

**<1>**

```java
persons.sort(new PersonComparator()); 
```

**<2>**

```java
Collections.sort(persons,new PersonComparator2());
```

**<3>**

```java
Collections.sort(persons, (Person o1, Person o2) -> {
    	   
    	 if (o1.name.equals(o2.name))
           return o1.age - o2.age; 
       
       return o1.name.compareTo(o2.name); // String은 compareTo가 overriding 되어있음
       	
       } );
```

## 람다표현식

매개변수 자리에 직접 메소드를 작성해준다

```java
Collections.sort(Class_1,() → { 메소드 });]
//()에는 메소드가 매개변수가 필요하면 매개변수 자리
```

- 람다 인터페이스는 메소드를 한 개 가지고 있다.