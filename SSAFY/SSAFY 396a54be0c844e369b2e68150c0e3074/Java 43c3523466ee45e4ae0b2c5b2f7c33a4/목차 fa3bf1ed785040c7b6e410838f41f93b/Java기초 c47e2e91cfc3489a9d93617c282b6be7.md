# Java기초

## Java개발환경

1. 컴파일 : 프로그래밍 언어 → 바이트코드로 변환 → javac 명령
    - 자바는 컴파일을 한번만 하면 된다.
2. JVM : 바이트코드 → 기계어로 변환하여 실행→ java 명령
    - 자바 바이트코드를 실행할 수 있는 주체
    - 번역가 : 바이트 코드를 운영체제의 언어에 맞는 기계어로 번역해줌
    - JVM은 플랫폼 독립적이지 않다. 운영체제에 맞게 다운로드
        - 자바는 플랫폼 독립적
- JDK (Java Development Kit) 자바개발도구 = JRE + 개발에 필요한 도구(컴파일러)
    - win, linux, mac에 따라 다운로드 다름
    - JRE (Java Runtime Environment) 자바 실행환경 = JVM(Java Virtual Machine) : 자바 실행을 위한 것

<aside>
💡 32bit 컴퓨터는 메모리 주소를 32bit (4byte) 까지 인식할 수 있다.

</aside>

## JVM 메모리 구조

- JVM이 알아서 메모리 관리
    - 메모리 관리를 개발자가 하지 않는다.
- GC가 메모리를 관리한다.
    - Heap영역 (Class 영역포함)에 생성된 메모리 관리 담당
- .java를 컴파일 후(.class 바이트 코드로 변환) 실행을 하면 그때 JVM위에 올라간다.

### 실행

<메모리에 로딩>

- 클래스 영역 = 메소드 영역 = static 영역
    - 클래스(설계도)와 관련된 정보를 저장
    - 객체생성 없다

---

<실행 중>

- 힙 영역
    - 인스턴스가 생성되면 클래스 영역에 저장된 클래스(설계도)를 바탕으로 만들어진 객체(인스턴스) 저장
    - 문자열 풀(Strign pool)에 문자열 저장
- 스택
    - main이 가장 먼저 호출
    - 메소드 호출시 그 위에 메소드가 쌓인다.
    - 인스턴스 생성시 참조변수에 힙 영역에 있는 인스턴스를 참조하는 참조값 저장

### 문법적 특징

1. 로딩시점
    - static : 클래스 로딩시 (인스턴스가 생성되기 전에)
    - non-static : 객체 생성시
2. 메모리상의 차이
    - static : 클래스당 하나의 메모리 공간만 할당
    - non-static : 인스턴스 당 메모리가 별도로 할당
3. 문법적 특징
    - static : 클래스 이름으로 접근
    - non-static : 객체 생성 후 접근

## 패키지

```java
com.ssafy.project_이름.module_이름
```

- 다른 패키지의 클래스를 사용하기 위해서는 import 과정이 필요
- 다른 패키지의 모든 클래스를 포함할 때는 *를 사용하기도 한다.
    - 하지만 패키지의 하위패키지는 import되지 않는다.
    - 자바에는 사실 하위 패키지라는 개념이 없다.
    - *그 패키지 않에 있는 모든 클래스만.
- 기본적으로는 패키지 않에 있는 것을 사용하지만 import하면 그 패키지를 사용한다.
- 서로다른 패키지에 있지만 클래스 이름이 같다면
    - 풀패키지 명을 사용한다.
    
    ```java
    패키지명.클래스명
    ```
    

### 캡슐화

1. 속성과 행위를 함께 묶어 모듈로 만든 것
2. 정보 은닉

- 접근제한자 사용
    - 클래스, 멤버 변수, 멤버 메서드 등의 선언부에서 접근 허용 범위를 지정
- getter(접근자), setter(설정자)를 이용하여 캡슐화 구현
    - 함수하나 만드는 건데 java에서 만들어논 private변수에 접근하는 이름일 뿐 **get변수명**
    - getter, setter 안에 다른 로직을 추가할 수 있다.

```java
//getter
get변수명()
//setter
set변수명(매개변수)
```