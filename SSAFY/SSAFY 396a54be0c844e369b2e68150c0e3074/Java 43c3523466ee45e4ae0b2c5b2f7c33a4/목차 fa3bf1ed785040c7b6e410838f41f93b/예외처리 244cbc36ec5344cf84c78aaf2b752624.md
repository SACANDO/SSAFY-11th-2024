# 예외처리

### 프로그램의 오류(버그)

- 발생시점에 따라
    - 컴파일 에러 : 문법이 틀려서
    - 런타임 에러 : 컴파일ok → 실행 ok→ 실행과정에서 문제. nullpointerror, indexerror, /0
    - 논리적 에러 : 원하는 결과가 아닌 경우. 테스트 케이스 실패
    
- 에러와 예외
    - Error : 발생하면 복구할 수 없는 심각한 오류
        - 프로그래머가 대비할 수 없음
        - 메모리부족
        - 스택오버플로우
    - Exception : 프로그래머가 적절한 코드를 통해 대비할 수 있는 오류
        - 프로그램의 정상적인 흐름을 방해한다.
        - 클래스 형변환 실패
        - 파일 읽기 실패
        - 원래 Exception이 발생하면 jvm이 해당 exception에 관련된 객체를 만들어서 던진다 → 따라서 그 에러를 받을 catch문이 필요한 것
- 예외 클래스의 계층
    - 런타임 exception가 아닌것은 다 컴파일 exception
        - RuntimeException클래스들
            - 프로그래머 실수
            - unchecked exception : 대처코드가 없어도 컴파일 문제는 없다.
                - 예외처리 안해도 된다.
                - try catch로 할수 있다
        - Exception클래스들
            - 사용자 실수 등 외적 요인
            - checked exception : 대처코드가 없으면 컴파일 진행 안됨
                - 빨간줄 - 실행전에 오류 체크를 해준다
                - 예외처리를 강제
                - try catch로 해야한다
    - Serializable
        - Throwable
            - Exception
                - RuntimeException
    
    ### try catch 문
    
    ```java
    try {
     // (1) 예외가 발생할 수 있는 코드
     // (2) 정상코드
    } catch (Exception e) { // exception 종류를 잘 적어줘야 함
    	// (3) 예외가 발생했을 때 처리할 코드
    }
    //(4) 일반코드
    ```
    
    - 예외가 발생했을 때 : 1→3→4
    - 예외가 발생하지 않았을 때 : 1→2→4
    
    ```java
    try {
    	// 예외 발생 가능한 코드
    }
    catch(ArrayIndexOutOfBoundsException | ArithmeticException e) {
    	
    	// 둘중에 하나의 오류가 발생했습니다
    	if(e instanceof ArithmeticException) {
    		// 계산 오류입니다
    	}
    }
    ```
    
    ### catch문은 여러개 올 수 있음
    
    ```java
    try {
    	// 예외 발생 가능한 코드
    }
    catch(ArithmeticException e) {
    	if(e instanceof ArithmeticException) {
    		// 계산 오류입니다
    	}
    
    }
    catch(ArrayIndexOutOfBoundsException e) {
    	//인덱스 오류 입니다	
    }
    catch(Exception e) {
    	// 오류가 발생했습니다.
    	sysout(e.getMessage()); // 오류 메세지 출력
    	e.printStackTrace(); // 오류 다 출력
    	}
    ```
    
    - Exception도 다형성이 적용 됨
    - 예외처리의 조상타입은 가장 밑에
    - 조상이 처리해버리면 자식이 처리할 기회가 없음.
    - 상속관계가 없는 경우는 무관
    
    ### CheckedException
    
    ```java
    //CheckedException
    public class ThrowTest1 {
    	// 빨간줄 -> throws해서 위임할 수 있다. : 나를 호출한 곳에 책임이 다시 넘어감
    	//		-> 직접처리(try catch)를 하지 않는다면 throws를 써야한다. 
    	// 즉 둘 중 하나는 반드시 해야한다. 
    	public static void main(String[] args) {
    		
    		try {
    		method1();
    		} catch (Exception e){
    			System.out.println("예외 발생");
    		}
    	}
    	
    	public static void method1() throws ClassNotFoundException{
    		method2();
    		
    		//throw : 호출한 곳에서 다시 처리하거나 위임
    	}
    	
    	public static void method2() throws ClassNotFoundException{
    		Class.forName("SSAFY");
    	}
    }
    ```
    
    - 내가 처리하고 싶은 부분에 try catch를 써야 제대로 종료가 된다.
    - 
    
    ### UncheckedException
    
    ```java
    public class ThrowTest2 {
    	// UncheckedException
    	// 빨간줄없음.
    	// 예외처리를 강제하지 않는다.
    	// throws도 강제하지 않는다. 
    	// 하고싶으면 try catch로 해라
    
    	public static void main(String[] args) {
    		method1();
    
    	}
    	
    	public static void method1() {
    		try {
    		method2();
    		} catch(ArithmeticException e) {
    			System.out.println("method1에서 처리가 될까요?");
    		}
    		// 처리가 됨. 
    		// 내부적으로는 예외를 넘기고 있다. 
    		// 결국에 처리되지 않았을 때 비정상적 종료
    	}
    	
    	public static void method2() {
    		int i =1/0;
    	}
    }
    ```
    
    - unchecked이지만 아무튼 예외는 발생했기 때문에 예외 처리는 한다.
    
    ## 메서드 재정의와 throws
    
    - throws는 내가 예외를 던질 수 있다는 표시를 해놓는 것
        - 던지면 호출을 한 곳으로 돌아감
    - main이든 다른 메소드든 그 예외를 받아서 처리를 해줘야 함
    - 메서드 재정의 시 조상클래스가 메서드가 던지는 예외보다 부모 예외를 던질 수 없다
        - 작은 실수 인데 큰 실수를 던질 수 없다
    
    ```java
    import java.io.FileNotFoundException;
    import java.io.IOException;
    
    class Parent {
    
    	public void method1() throws IOException {
    
    	}
    
    	public void method2() throws ClassNotFoundException {
    
    	}
    
    	public void method3() {
    
    	}
    
    }
    
    //ThrowTest3는 Parent클래스의 자식
    public class ThrowTest3 extends Parent {
    	@Override
    	public void method1() throws FileNotFoundException {
    		// IOException의 자식임. 더 작은 실수 던지기 가능!
    	}
    
    	@Override
    	public void method2() throws Exception {
    		// 안된다. 부모보다 더 큰 실수를 던질 수 없다.
    	}
    
    	@Override
    	void method3() {
    		// 안된다. default로 부모의 접근제한자보다 범위가 좁으면 안된다
    	}
    }
    ```
    
    ### finally 구문
    
    ```java
    public class FinallyTest1 {
        public static void main(String[] args) {
    
            int num = 0;
            
            try {
                System.out.println("1"); 
                int i = 1 / num;
                System.out.println("2");
            } catch (ArithmeticException e) {
                System.out.println("3");
            } finally {
                System.out.println("4");
            }
            System.out.println("5");
        }
    
    }
    ```
    
    - 정상실행 시 : 1 2 4 5
    - 예외발생 시 : 1 3 4 5
    - 예외 미처리 시  : 1 4 (중단 - 프로그램이 정상적으로 종료되지 않음)
    - catch 문에 return이 들어가면 (예외 발생시) : 1 3 4
        - 즉 return을 해도 finally는 반드시 실행된다.
    - try문에 return이 들어갔다면(정상 실행시) : 1 2 4
        
        → return은 try또는 catch문에 넣는다. 
        
    
    ### 사용자 정의 예외
    
    -