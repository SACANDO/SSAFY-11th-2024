# 문법

### 기본

### print

```java
print //줄 안바꿈
println //줄바꿈
printf //특정 포맷으로 프린트
%d //정수
%4d //4칸을 확보하여 오른쪽부터 채움
%-4d //4칸을 확보하여 왼쪽부터 채움
%04d //4칸을 확보하여 공백은 0으로 채움
```

### 문자열

- 출력포맷을 적용하기 위한 함수

```java
String.format()
//괄호 안에는 printf랑 사용법 같음

public String toString() {
		String info = "Restaurant [resId=%d, name=%s, address=%s, signatureMenu=%s, rate=%d]";
		return String.format(info, resId,name,address,signatureMenu,rate);
	}
```

### 1차원배열

- 변수 : 어떤 애인지 몰라도 반장만 부르면 써먹을 수있음
    - 메모리공간을 확보하고 이름을 붙여준 것임
- 상수 : 개별적인 학생이라 학생이름 제대로 불러야 함
- 배열은 왜 필요한가?
    - 학생이 모인 학급이 있고 학급이 모인 학년으로 묶어서 관리하기 위해
    - 마찬가지로 연관된 데이터들을 그룹핑해서 관리하기 위한 데이터 타입

### 배열이란

- **같은 종류의 데이터**를 저장하기 위한 자료구조
    - 데이터형 동일, 개수가 많을 때
    - 크기는 고정
- **배열을 객체로 취급 = 참조형 : 변수에는 주소값이 저장되어 있음**
    - 근데 막 주소값이 저장되어있다 라고 할 수는 없다. 그냥 참조형이라고 알면 됨
- 배열의 요소 참조하려면
    - 배열이름과 인덱스 이용
    - 인덱스 번호로 각 요소에 접근
- 배열이름.length로 배열 길이 조회 가능
- 배열 길이는 임의 변경 불가
    - 변경 필요시 새로운 배열생성 후 옮기기

### 배열 생성과 초기화

```java
type[] 배열이름 = new type [length]; //해당 type의 기본값으로 초기화 되어 생성됨
type[] 배열이름 = new type[] {value1, value2...}; // 생성 후 초기화
type[] 배열이름={value1, value2...}; //선언과 동시에 초기화 할 때만 가능한 형태

//틀린 선언
type[] 배열이름 = new type[length] {value1, value2...};
```

- 배열을 선언만 한다면
    
    ```java
    type[] 배열이름;
    ```
    
    - 배열을 가리키는 참조 주소값을 저장할 배열 변수만 선언된 것일 뿐
    - 실제 배열 객체가 생성된 것은 아님
    - 이후 new type[] {}로 생성

```java
boolean :false
char : '\u0000' // 결과가 안 보이지만 \u0000이 들어있음 
byte, short, int : 0
long : 0L
float : 0.0f
double : 0.0
참조형 변수 : null //아무것도 참조하지 않음
```

### 배열탐색 및 출력

- for-each

```java
for (type e : 반복할 수 있는 것(배열)) {
	System.out.println(e);
}

//콜론뒤의 값에서 하나씩 꺼내서 e에 담아라
//단, **read-only**
//수정할 수 없다.
```

반복문과 배열은 떼려야 뗄 수가 없다. 

```java
system.out.println(Arrays.toString(배열이름));
// [null, null, null, null, null] 형태로 출력
```

### 배열 복사 및 크기 변경

- 배열을 새로 만들고 반복문으로 옮기기

```java
for(int i=0; i<nums.length; i++) {
			tmp[i] = nums[i];
		}
		System.out.println(Arrays.toString(tmp));
```

- Arrays.copyOf(원본배열, 새로운 배열의 크기)

```java
 int[] tmp2 = Arrays.copyOf(nums, 10);
```

- System.arraycopy(원본배열, 원본배열의 시작점, 복사배열, 복사배열의 시작점, 복사할 크기)

```java
int[] tmp3=new int[10];
		System.arraycopy(nums,0,tmp3,0,nums.length);
		System.out.println(Arrays.toString(tmp3));
```

### 배열에서 최대값, 최소값 찾기

```java
int[] nums = {13,56,1,99,85};
		int max =0; //충분히 작은 값 //Integer.MIN_VALUE // nums[0]
		int min =100; //충분히 큰 값 //Integer.MAX_VALUE // nums[0]
		
	for(int i : nums) {
			if (i>max) {
				max=i;
			}
			if (i<min) {
				min=i;
			}
		}
		System.out.printf("max : %d, min : %d", max,min);
```

### 구간합 (N~M, 단 항상 N<M)

- 반복문 N~M까지 돌기
- 반복문, 0~M합 - 0~(N-1)합 (M은 포함, N은 미포함)
- prefixSum 배열생성

```java
int[] nums = {13,56,1,99,85,56,84,93,54,89};
		int N=5;
		int M=9;
		
		int[] prefixSum= new int[nums.length];
		prefixSum[0] = nums[0];
		for (int i =1; i<nums.length; i++) {
			prefixSum[i]= prefixSum[i-1]+nums[i];
		}

		
		int sum2 =0;
		if(N==0) {
			sum2 =prefixSum[M];
		}
		else {
			sum2 = prefixSum[M] - prefixSum[N-1];
		}
		System.out.println(sum2);
```

### 빈도수

```java
int[] intArray= {3,7,2,5,9,2,8,1,1,5,3};
		
int[] count = new int[10]; // 0-9
		
for(int i =0; i<intArray.length; i++) {
	count[intArray[i]]++;
}
System.out.println(Arrays.toString(count));
```

### 중간값 찾기

```java
int[] arr = {1,1,3,5,7,8,9,6,4,5,6,2,1,2,5};
		System.out.println("배열의 길이 : " + arr.length);
		System.out.println("중간값 : " + (arr.length/2+1) +"번째 값");
		
		int[] count = new int[10];
		for(int i=0; i<arr.length; i++) {
			count[arr[i]]++;
			
		}
		System.out.println(Arrays.toString(count));
		
		//
		int sum =0;
		int center=0;
		for(int i=0; i<count.length; i++) {
			sum += count[i];
			System.out.println("현재"+ i + "까지의 합" + sum);
			if (sum >= arr.length/2+1) {
				center = i;
				break;
```

### 인덱스

```java
if ((j+1) % num == 0) { //인덱스가 1부터 시작한다고 '여길때' j+1
					switches[j] = switches[j] == 0 ? 1 : 0; //실제 인덱스에 저장 j
				}
```

### 2차원배열

- 배열안에 다른 배열의 참조값이 있는 것

### 2차원 배열 선언

```java
int[][] iArr;
```

### 2차원 배열 생성[행][열]

```java

//1. 기본값으로 초기화

배열의 이름 = new type[1차원 배열의 개수][1차원 배열의 크기] ;

// 2. 각각의 배열은 크기가 다를 수 있다.
// 1차원 배열은 아직 생성되지 않았고, 연결되지 않음. 열에는 null값이 들어있음 
//(참조형 변수는 원래 null로 초기화 됨)

배열의 이름 = new type[1차원 배열의 개수][];

int[][] arr1 = new int[3][];
arr1[0] = new int[] {1,2,3};

//3. 원하는 값으로 초기화, new type 생략 가능
ㅌ`배열의 이름 = new type[][]{
	{  }, {  }
}; 
```

### 2차원 배열 탐색

중첩 반복문

- 행 우선탐색
- 열 우선탐색
- 지그재그 탐색

### 2차원 배열 복사

```java

```

### 연산

```java
double i = 5/2; // 정수 연산 정수 => 정수
System.out.println(i); // 2.0 출력
double j = 5/2.0; // 실수 연산 정수 => 실수 (순서는 상관없이 하나만 실수이면 됨)
System.out.println(j); // 2.5 출력
```

### 비교연산

- 문자열
    - String은 문자열이 같으면 같은 주소값을 참조한다
    - 단, new String()으로 새로운 인스턴스를 생성하면 다른 주소값을 참조한다.

```java
문자열에서 
==, != : 참조값(주소값) 비교
.equals : 값 비교

따라서 equals로 비교한다.
```

### 반복문

```java
//순서 : 초기화식 -> 조건식이 맞으면 -> 반복 -> 증감식 후 다시 조건식 
		//			  -> 조건식이 틀리면 종료
		
for(int i=0; i<5; i++) {
	System.out.println("메롱");

out : // 라벨을 통해서 바깥 반복문을 빠져나갈 수 있다. 
out : for ~
				for ~
					break out;
```

### 반복문 초기식, 조건식

- 반복횟수
    
    ```java
    < 이면 미포함
     -> 조건식 값 - 초기식 값
    ```
    
    ```java
    <=이면 포함
    -> 조건식 값 - 초기식 값 + 1
    ```