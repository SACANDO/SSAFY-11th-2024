# 브루트포스

1. 냅다 for문
2. 조합
    1. 부분집합
3. 순열

# 집합과 조합론

- 부분집합
    - 반복문
    - 비트마스킹
    - 재귀
- 조합 : n개중 r개를 뽑기 (중복을 허용하지 않는다. 경우에 따라 중복조합)
    - 순서 상관 없이 내용이 같으면 같은 거
    - 포함시켰다 vs 안 시켰다
        - 반복문
        - 재귀
        - 재귀+반복문
- 순열
    - 순서가 다르면 다른 거
        - 중복순열도 있는데,, 뭐 그거는 문제 나오면 그때,,
    - 1번일때
        - 1번일 때
            - 1번일 때
            - 2번일 때
        - 2번일 때
            - 1번일 때
            - 2번일때
    - 2번일 때 요런식으로 중복 되는 거 빼고 모든 경우의 수
        - 반복문
        - swap
        - 재귀
        - boolean배열 / 비트마스킹
        - next permutation

<aside>
💡 중첩 반복문은 재귀랑 똑같음
반복문에 걸려 있느냐 vs 시스템스택 아래에 쌓여 있느냐 차이

</aside>

단 모양새가 재귀가 더 이쁨
똑같은 **코드를 반복하기 위해서 반복문을 걸어준다면 아래와 같다**

```java
package 순열조합연습;

public class 순열_반복문 {
	public static void main(String[] args) {
		int cnt=0;
		boolean[] check = new boolean[10];
		
		for(int i=1; i<=9; i++) {
			check[i]=true;
			for(int j=1; j<=9; j++) {
				if(check[j]) continue;
				check[j]=true;
				for(int q = 1; q<=9; q++) {
					if(check[q]) continue;
					check[q] =true;
					System.out.println(i+" "+j+" "+q);
					cnt++;
					check[q]=false;
				}
				check[j]=false;
			}
			check[i]=false;
			
		}
		System.out.println("count : " + cnt);
	}
}

```

- check를 걸어주고 풀어주는 게 반복된 작업인데 반복문은 이렇게 모든 반복문마다 중복해서 작성해줘야 한다.

반면 재귀로 짜면 다음 함수를 부른 곳에서 멈춰 있기 때문에 코드 사이로 다시 함수전체가 들어가는 형태가 된다. 그렇다면 반복되는 코드는 굳이 여러번 적어줄 필요가 없이 한번만 적어주면 알아서 프로그램이 그렇게 돌아간다.  

```java
package 순열조합연습;

import java.util.Arrays;

public class 순열_재귀 {
	static int cnt=0;
	static boolean[] check = new boolean[5];
	static int[] arr = {1,2,3,4,5};
	static int[] chosen= new int[5];
	public static void main(String[] args) {
		perm(0);
		System.out.println(cnt);
	}
	static void perm(int idx) {
		if(idx>=5) {
			System.out.println(Arrays.toString(chosen));
			cnt++;
		}
		
		for(int i=0; i<5; i++) {
			if(check[i]) continue;
			chosen[idx] =  arr[i];
			check[i]=true;
			//다음 반복문을 부를 차례
			perm(idx+1);
			//반복문이 끝나면 실행될 코드
			check[i]=false;
		}
	}
}

```