# 상속과 다형성

**<목차>**

## 상속

어떤 클래스의 특성을 그대로 갖는 새로운 클래스를 정의한 것

1. 확장성, 재 사용성
    - 부모의 생성자와 초기화 블록은 상속X
    - static블록도 상속받지 않는다.
2. 클래스 선언시 extends 키워드를 명시
    - 자바는 다중 상속 허용X. 한번에 하나만 상속받을 수 있다. = 단일상속지원
3. 관계
    - 부모(super), 자식(sub)
4. 자식 클래스는 부모 클래스의 멤버변수, 메소드를 자신의 것처럼 사용할 수 있다. 
5. Object 클래스는 모든 클래스의 조상 클래스
    - 별도의 extends선언이 없는 클래스는 extends Object가 생략

### super

부모의 것을 호출하겠다.

```java
super(변수1,변수2...)
// 부모의 생성자 호출

super.eat()
// 부모의 메소드 호출
```

- **모든 생성자의 첫줄에는 super(); 가 생략되어 있다.**

→ 단, super()과 this()는 둘중에 하나만 쓸 수 있다.

- super(), 즉 부모생성차 호출은 첫줄에 와야 한다.
- this()는 자신의 생성자 호출, this는 첫줄에 와야 한다.

→ this를 호출하지 않는 생성자가 결국에는 super을 호출하고 결국 Object로 간다.

→ 부모가 기본 생성자를 호출하지 않으면 그 안에 super()가 포함되어 있다

- 여기서는 Object의 기본 생성자를 호출하는 것임.

### 오버라이딩(재정의, overriding)

@ : 어노테이션_ 컴파일러에게 알려주는 주석문_이것은 오버라이딩 한 것이다. 

- 상위 클래스에 선언된 **메서드**를 자식 클래스에서 재정의 하는 것
    - 재정의 하고 싶은 것만 재정의 하면 됨
- **메서드의 이름, 반환형, 매개변수 (타입 개수, 순서) 동일해야 한다.**
- 하위 클래스의 접근 제어자 범위가 상위클래스보다 크거나 같아야 한다.
    - 부모의 기능을 없애거나 축소시킬 수 없다.
- 조상보다 더 큰 예외를 던질 수 없다.

## Object

- 가장 최상위 클래스로 모든 클래스의 조상
- Object의 멤버는 모든 클래스의 멤버

**Object의 멤버 메소드를 오버라이딩 하지 않으면 모든 메소드는 Object가 가진 메소드가 나온다.** 

- ex) toString(), hashCode() 등
- Object의 기본메소드는 참조값을 나타내는데, 궁금한 건 내용이기 때문에 오버라이딩을 해야 함
- 기본 참조값
    
    ```java
    패키지명.클래스명@주소값
    ```
    
- String은 객체이기 때문에 Object를 상속하고 있다.
    - 예를들어 String은 Object의 equals 메소드를 오버라이드 해서 값 비교를 하고 있음
    
    ```java
    // Object의 equals
    public boolean equals(Object obj) {
    	return (this == obj); //주소비교
    }
    ```
    

### hashCode

- 객체의 해시 코드 : 시스템에서 객체를 구별하기 위해 사용되는 정수값
    - HashSet, HashMap 등에서 객체의 동일성을 확인하기 위해 사용

### final

- 상속할 수 없다.
- 결코 수정될 수 없다.
- final 클래스 : 상속금지
- final 메소드 : overriding 금지
- final 변수 : 값 수정 금지. 상수화

```java
public final class class_1;
public final void function_1;
final int a = 1;
```

## 다형성

- 상속관계에 있을 때 조상 클래스의 타입으로 자식 클래스 객체를  참조할 수 있다.
- 부모클래스의 타입으로 자식 객체를 참조하더라도 실제 객체가 자식 클래스의 객체라면 
자식 클래스에서 오버라이드 한 메서드가 실행된다.
    - 거꾸로는 되지 않는다
- 자손 클래스의 인스턴스가 메모리에 올라가면 메모리는 조상의 모든 메소드와 속성을 다 가지고 있는다.

### 참조변수의 형변환

- 자손타입 → 조상타입 (묵시적 형변환)
    - 형 변환 생략 가능

```java
Student st = new Student();
Person p = st;

//간단히
Person p = new Student();
```

- 조상타입 → 자손타입 (명시적 형변환)
    - 오류가 발생하면 책임은 알아서
    - 실제 올라와 있는 Student 객체는 없어서 확인 후 사용

```java
Person p = new Person();
if (person instanceof Student) {
	Student st = (Student) p;
	student.study();
}
```

### 참조변수와 인스턴스 멤버의 관계

- hiding

```java
public class Parent {
	String x = "parent";
}

public class Child extends Parent{
	String x = "Child";
}

//동적바인딩

Parent c = new Child();
c.method(); // 멤버 메소드는 다형성을 따른다. 
System.out.println(c.x); // 멤버변수는 다형성을 따르지 않는다.

```

- 따라서 보통 멤버변수는 부모의 변수 즉, 물려받은 것을 쓴다.
- 부모의 타입으로 자식을 바라보면 멤버변수는 부모 것이 나온다.
    - 자식 타입으로 바라보면 자식의 멤버변수 그대로 나온다.