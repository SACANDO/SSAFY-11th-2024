# 그래프

1. BFS, DFS : 사방탐색 등을 하는 방식
2. 크루스칼 : 최소비용 무향 연결 그래프를 하나 만드는 것
3. 프림 : 크루스칼이랑 같은데 다익스트라랑 비슷한 방식
4. 다익스트라 : 두 정점을 잇는 최소비용 그래프. 거리나 비용 구하기

# 그래프 비용

### 서로소 집합

- 상호 배타 집합
- 중복 포함된 원소가 없는 집합 = 교집합이 없음
- 각 집합은 대표자를 통해 구분

표현방법

- 연결리스트
- 트리

상호 배타 집합 연산

- Make-set(x) : 집합 생성
- Find-Set(x) : 대표 반환
- Union(x,y) : 인수합병

집합 표현

- 연결리스트 → 사용 잘 안함
    - rep,tail,next,대표를 가리키는 포인터
    - 연결이 직관적으로 안보인다
- **트리 :** 실제 구현은 **배열**
    - 자식 노드가 부모노드를 가리키며 루트노드가 대표자
    - rank를 이용한 union
        - 랭크가 높은 집합에 랭크가 낮은 집합을 합친다.
        - 두 집합의 랭크가 같으면 그냥 아무렇게나 합치고 랭크++
    - 대표를 찾을 때 거쳐가는 노드마다 대표를 가리키도록 바꾼다

### 최소신장트리(MST)

- 신장트리 중에서 사용된 간선들의 가중치 합이 최소인 트리
- N개의 정점을 가지는 그래프에 대해 반드시 N-1개의 간선을 사용
- 사이클 포함 x
- 대표적 알고리즘 크루스칼, 프림 (그리디)

<aside>
💡 아무튼 크루스칼이나 프림이나 간선이 100만개를 넘으면 의심해봐야 함
그렇게 푸는 게 아니고 다른 쪽으로 머리를 써서 줄여야 함
휴

</aside>

### 크루스칼 알고리즘

1. 최초 모든 간선을 가중치에 따라 오름차순으로 정렬
2. 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴
    1. 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택
3. N-1개의 간선이 선택될 때까지 반복

### 프림 알고리즘

1. 임의 정점을 선택하여 시작 (보통 0 ,1번)
2. 선택한 정점과 인접하는 정점들 중의 최소 비용의 간선이 존재하는 정점을 선택
3. 모든 정점이 선택될 때 까지 2과정을 반복
- visited처리로 사이클 안 생기는 거 보장 됨
    
    ![Untitled](%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%20979927601cf54c44acc2ab06bd4df48b/Untitled.png)
    

## 다익스트라 알고리즘

- 최단 경로 : 가중치가 있는 그래프의 **두 정점** 사이의 경로들 중 간선의 가중치 합이 최소인 경로
- 다익스트라 알고리즘 : 음의 가중치 허용 x
    - 벨만 포드 : 음의 가중치 허용 o
1. 시작정점 입력
2. 거리저장 배열을 무한으로 초기화
3. 시작점에서 갈 수 있는 곳 값 갱신
4. **아직 방문하지 않은 점들이 가지고 있는 거리값과 현재 정점에서 방문하지 않은 정점까지의 가중치의 합이 작다면 갱신**
5. 모든 정점을 방문할 때 까지 반복
- 방문했다(뽑혔다) : 이게 최선이다.

<aside>
💡 프림이든 다익스트라든 일단 방문을 했다는 건 시작점에서 그 점까지의 거리가 제일 작아서 pq에서 뽑혔다는 거고 걔부터 탐색해서 갱신하는 거니까 다음 번에는 방문하지 않아도 걔는 최소값이 이미보장 되어 있는 거.

</aside>